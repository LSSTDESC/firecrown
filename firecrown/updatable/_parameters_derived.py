"""Derived parameters functionality."""

from __future__ import annotations
from collections.abc import Iterator, Sequence


class DerivedParameter:
    """Represents a derived scalar parameter generated by an Updatable object.

    This class provide the type that encapsulate a derived scalar quantity (represented
     by a float) computed by an Updatable object during a statistical analysis.
    """

    def __init__(self, section: str, name: str, val: float):
        """Initialize the DerivedParameter object."""
        self.section: str = section
        self.name: str = name
        if not isinstance(val, float):
            raise TypeError(
                "DerivedParameter expects a float but received a " + str(type(val))
            )
        self.val: float = val

    def get_val(self) -> float:
        """Return the value of this parameter."""
        return self.val

    def __eq__(self, other: object) -> bool:
        """Compare two DerivedParameter objects for equality.

        This implementation raises a NotImplemented exception unless both
        objects are DerivedParameter objects.

        Two DerivedParameter objects are equal if they have the same
        section, name and value.
        """
        if not isinstance(other, DerivedParameter):
            raise NotImplementedError(
                "DerivedParameter comparison is only implemented for "
                "DerivedParameter objects"
            )
        return (
            self.section == other.section
            and self.name == other.name
            and self.val == other.val
        )

    def get_full_name(self):
        """Constructs the full name using section--name."""
        return f"{self.section}--{self.name}"


class DerivedParameterCollection:
    """Represents a list of DerivedParameter objects."""

    def __init__(self, derived_parameters: Sequence[DerivedParameter]):
        """Construct an instance from a sequence of DerivedParameter objects."""
        if not all(isinstance(x, DerivedParameter) for x in derived_parameters):
            raise TypeError(
                "DerivedParameterCollection expects a list of DerivedParameter"
                "but received a " + str([str(type(x)) for x in derived_parameters])
            )

        self.derived_parameters: dict[str, DerivedParameter] = {}

        for derived_parameter in derived_parameters:
            self.add_required_parameter(derived_parameter)

    def __len__(self) -> int:
        """Return the number of parameters contained."""
        return len(self.derived_parameters)

    def __add__(self, other: None | DerivedParameterCollection):
        """Add two DerivedParameterCollection objects.

        Return a new DerivedParameterCollection with the lists of DerivedParameter
        objects.

        If other is none return self. Otherwise, constructs a new object representing
        the addition.

        Note that this function returns a new object that does not share state
        with either argument to the addition operator.
        """
        if other is None:
            return self

        return DerivedParameterCollection(
            list(self.derived_parameters.values())
            + list(other.derived_parameters.values())
        )

    def __eq__(self, other: object):
        """Compare two DerivedParameterCollection objects for equality.

        This implementation raises a NotImplemented exception unless both
        objects are DerivedParameterCollection objects.

        Two DerivedParameterCollection objects are equal if they contain the same
        DerivedParameter objects.
        """
        if not isinstance(other, DerivedParameterCollection):
            raise NotImplementedError(
                "DerivedParameterCollection comparison is only implemented for "
                "DerivedParameterCollection objects"
            )
        return self.derived_parameters == other.derived_parameters

    def __iter__(self) -> Iterator[tuple[str, str, float]]:
        """Implementation of lazy iteration through the collection."""
        for derived_parameter in self.derived_parameters.values():
            yield (
                derived_parameter.section,
                derived_parameter.name,
                derived_parameter.get_val(),
            )

    def add_required_parameter(self, derived_parameter: DerivedParameter):
        """Adds derived_parameter to the collection.

        We raises an ValueError if a required parameter with the same name is already
        present in the collection.
        """
        required_parameter_full_name = derived_parameter.get_full_name()
        if required_parameter_full_name in self.derived_parameters:
            raise ValueError(
                f"RequiredParameter named {required_parameter_full_name}"
                f" is already present in the collection"
            )
        self.derived_parameters[required_parameter_full_name] = derived_parameter

    def get_derived_list(self) -> list[DerivedParameter]:
        """Implement lazy iteration through the contained parameter names."""
        return list(self.derived_parameters.values())
