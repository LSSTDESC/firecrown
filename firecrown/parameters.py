"""Classes and functions to support groups of named parameters.

"""

from __future__ import annotations
from typing import Iterable, List, Dict, Set, Optional
from abc import ABC, abstractmethod
import numpy as np


def parameter_get_full_name(prefix: Optional[str], param: str) -> str:
    """Form a full parameter name from the given (optional) prefix and name.

    Parameter names, as stored in SACC, for example, contain an optional
    prefix; if a prefix is present, it will be separated from the name by
    an underscore.

    Prefixes and names should avoid containing embedded underscores. This
    is currently not enforced in the code.

    The parameter name can not be empty, even if accompanied by a prefix;
    this is enforced in the code.

    Ill-formed parameter names result in raising a ValueError.
    """
    if len(param) == 0:
        raise ValueError("param must not be an empty string")

    if prefix:
        return f"{prefix}_{param}"
    return param


class ParamsMap(Dict[str, float]):
    """A specialized Dict in which all keys are strings and values are floats.

    The recommended access method is get_from_prefix_param, rather than indexing
    with square brackets like x[].
    """

    def get_from_prefix_param(self, prefix: Optional[str], param: str) -> float:
        """Return the parameter identified by the optional prefix and parameter name.


        See parameter_get_full_name for rules on the forming of prefix and name.
        Raises a KeyError if the parameter is not found.
        """
        fullname = parameter_get_full_name(prefix, param)

        if fullname in self.keys():
            return self[fullname]
        raise KeyError(f"Prefix `{prefix}`, key `{param}' not found.")


class RequiredParameters:
    """Represents a sequence of parameter names.

    This class provides some type safety to distinguish between an arbitrary
    list of strings, and one intended to be a list of required parameter names.

    An instance can be created from a list of strings.
    Instances can be concatenated using `+`, and compared for equality using `==`.

    To iterate through the names (which are strings), use `get+params_names`,
    which implements lazy evaluation.
    """

    def __init__(self, params_names: Iterable[str]):
        """Construct an instance from an Iterable yielding strings."""
        self.params_names: Set[str] = set(params_names)

    def __add__(self, other: RequiredParameters):
        """Return a new RequiredParameters with the concatenated names.

        Note that this function returns a new object that does not share state
        with either argument to the addition operator."""
        return RequiredParameters(self.params_names | other.params_names)

    def __eq__(self, other: object):
        """Compare two RequiredParameters objects for equality.

        This implementation raises a NotImplemented exception unless both
        objects are RequireParameters objects.

        Two RequireParameters objects are equal if their contained names
        are equal (including appearing in the same order).
        """
        if not isinstance(other, RequiredParameters):
            return NotImplemented
        return self.params_names == other.params_names

    def get_params_names(self):
        """Implement lazy iteration through the contained parameter names."""
        params_names_set = set(self.params_names)

        for name in params_names_set:
            yield name


class DerivedParameter(ABC):
    """Represents a derived parameter generated by an Updatable object

    This class provide the type that encapsulate a derived quantity computed
    by an Updatable object during a statistical analysis.
    """

    def __init__(self, section: str, name: str):
        """Constructs a new derived parameter."""
        self.section: str = section
        self.name: str = name

    def get_full_name(self):
        """Constructs the full name using section--name."""
        return f"{self.section}--{self.name}"

    @abstractmethod
    def get_val(self):
        """Returns the value contained."""


class DerivedParameterScalar(DerivedParameter):
    """Represents a derived scalar parameter generated by an Updatable object

    This class provide the type that encapsulate a derived scalar quantity (represented by a float) computed
    by an Updatable object during a statistical analysis.
    """

    def __init__(self, section: str, name: str, val: float):
        super().__init__(section, name)

        if not isinstance(val, float):
            raise TypeError(
                "DerivedParameterScalar expects a float but received a "
                + str(type(val))
            )
        self.val: float = val

    def get_val(self) -> float:
        return self.val


class DerivedParameterArray(DerivedParameter):
    """Represents a derived array parameter generated by an Updatable object

    This class provide the type that encapsulate a derived array (represented by a numpy.ndarray) computed
    by an Updatable object during a statistical analysis.
    """

    def __init__(self, section: str, name: str, val_array: np.ndarray):
        super().__init__(section, name)

        if not isinstance(val_array, np.ndarray):
            raise TypeError(
                "DerivedParameterScalar expects a numpy.ndarray but received a "
                + str(type(val_array))
            )
        self.val_array: np.ndarray = val_array

    def get_val(self) -> np.ndarray:
        return self.val_array


class DerivedParameterCollection:
    """Represents a list of DerivedParameter objects."""

    def __init__(self, derived_parameters: List[DerivedParameter]):
        """Construct an instance from a List of DerivedParameter objects."""

        if not all(isinstance(x, DerivedParameter) for x in derived_parameters):
            raise TypeError(
                "DerivedParameterCollection expects a list of DerivedParameter but received a "
                + str([str(type(x)) for x in derived_parameters])
            )

        self.derived_parameters: List[DerivedParameter] = derived_parameters.copy()

    def __add__(self, other: DerivedParameterCollection):
        """Return a new DerivedParameterCollection with the lists of DerivedParameter objects.

        Note that this function returns a new object that does not share state
        with either argument to the addition operator."""
        return DerivedParameterCollection(
            self.derived_parameters + other.derived_parameters
        )

    def __eq__(self, other: object):
        """Compare two DerivedParameterCollection objects for equality.

        This implementation raises a NotImplemented exception unless both
        objects are DerivedParameterCollection objects.

        Two DerivedParameterCollection objects are equal if they contain the same DerivedParameter objects.
        """
        if not isinstance(other, DerivedParameterCollection):
            return NotImplemented
        return self.get_derived_list() == other.get_derived_list()

    def get_derived_list(self) -> List[DerivedParameter]:
        """Implement lazy iteration through the contained parameter names."""
        self.derived_parameters.sort(key=lambda x: f"{x.section}--{x.name}")

        return self.derived_parameters.copy()
