---
title: "Using Firecrown to Calculate Theoretical Predictions"
subtitle: "Version 1.8.0a0"
author:
  - Marc Paterno
  - Sandro Vitenti
format:
  html:
    toc: true
    theme: [serif, custom.scss]
    code-overflow: wrap
    code-fold: false
reference-location: margin
citation-location: margin
jupyter: python3
---

::: {.hidden}
```{python}
def doc_theme():
    return theme_minimal() + theme(
        panel_grid_minor=element_line(color="gray", linetype="--")
    )
```
:::

## Purpose of this document

Firecrown provides facilities for creating distributions for galaxies
$$
P(z|B_i, \theta) \equiv \frac{\mathrm{d}n}{\mathrm{d}z}(z;B_i, \theta),
$${#eq-Pi}
where $B_i$ is the $i$-th bin of the photometric redshifts, and $\theta$ is a set of parameters that describe the model. 

In Firecrown, this distribution is stored as a `InferredGalaxyZDist` dataclass in `firecrown.metadata`, which contains the redshifts, the corresponding probabilities and the data-type of the measurements. Firecrown also provides objects that generate this distributions given a chosen model. In `firecrown.generators`, we have the `ZDistLSSTSRD` class, which generates the redshift distribution according to the LSST Science Requirements Document (SRD). 

## LSST SRD Distribution

In the LSST SRD, the redshift distribution is described by a set of parameters $\theta = (\alpha,\,\beta,\,z_0)$, where the redshift distribution is given by
$$
P(z|\theta) = f(z;\alpha,\,\beta,\,z_0) = \frac{\alpha}{z_0\Gamma[(1+\beta)/\alpha]}\left(\frac{z}{z_0}\right)^\beta\exp\left[\left(\frac{z}{z_0}\right)^\alpha\right],
$${#eq-fz}
To obtain the distribution in each photometric redshift bin, we need to convolve this with a model for the photometric redshift errors, namely
$$
P(z_\mathrm{p}|z,\sigma_z) = \frac{1}{N(z)\sqrt{2\pi}\sigma_z(1+z)}\exp\left[-\frac{1}{2}\frac{(z-z_p)^2}{\sigma_z^2(1+z)^2}\right],
$${#eq-Pzp}
where 
$$
N(z) = \frac{1}{2}\mathrm{erfc}\left[-\frac{z}{\sqrt{2}\sigma_z(1+z)}\right].
$$
The redshift distribution (@eq-Pi) is then given by
$$
\begin{align}
P(z|B_i, \theta) &= \int_{z_{p,i}^\mathrm{low}}^{z_{p,i}^\mathrm{up}} \!\!\!\mathrm{d}z_p\,P(z_p|z,\sigma_z)P(z|\theta), \\
&= \int_{z_{p,i}^\mathrm{low}}^{z_{p,i}^\mathrm{up}} \!\!\!\mathrm{d}z_p\,\frac{1}{\sqrt{2\pi}\sigma_z(1+z)}\exp\left[-\frac{1}{2}\frac{(z-z_p)^2}{\sigma_z^2(1+z)^2}\right]f(z;\alpha,\,\beta,\,z_0).
\end{align}
$${#eq-lsst-srd}
where $B_i = \left(z_{p,i}^\mathrm{low}, z_{p,i}^\mathrm{up}, \sigma_z\right)$ provides the photometric redshift bin limits and the photometric redshift error in the form $\sigma_z(1+z)$.

The object `ZDistLSSTSRD` in Firecrown generates the redshift distribution according to the LSST SRD. The following code block demonstrates how to use this object to generate the redshift distribution for a given set of parameters $\theta$.

Below we calculate @eq-fz for year 1 and year 10 parameters from LSST SRD:
```{python}
import numpy as np
import firecrown
from firecrown.generators.inferred_galaxy_zdist import ZDistLSSTSRD

# These are the values of z at which we will evalute f(z)
z = np.linspace(0, 3.0, 100)

# We want to evaluate f(z) for both Y1 and Y10.
zdist_y1 = ZDistLSSTSRD.year_1()
zdist_y10 = ZDistLSSTSRD.year_10()

# Now we can generate the values we want to plot.
# Note that Pz_y1 and Pz_y10 are both numpy arrays:
Pz_y1 = zdist_y1.distribution(z)
Pz_y10 = zdist_y10.distribution(z)
```

The generated data are plotted in @fig-fz

```{python}
# | label: fig-fz
# | fig-cap: $\textrm{d}N/\textrm{d}z$ for both Year 1 and Year 10, using the formulation from the SRD.
# | fig-cap-location: margin
# | code-fold: true
from plotnine import *  # bad form in programs, but seems OK for plotnine
import pandas as pd

# The data were not originally generated in a dataframe convenient for
# plotting, so our first task it to put them into such a form.
# First we create a dataframe with the raw data.
data = pd.DataFrame({"z": z, "Y1": Pz_y1, "Y2": Pz_y10})
# Then we 'melt' the data into a longer form, which is more conveient for
# making multiple plots on the same axes, or for making panel (faceted) plots.
long = pd.melt(data, id_vars=["z"], var_name="year", value_name="fz")

# Now we can generate the plot.
(
    ggplot(long, aes("z", "fz", color="year"))
    + geom_point()
    + labs(y="dN/dz")
    + doc_theme()
)
```

Next, using the same SRD prescriptions, we want to generate the `InferredGalaxyZDist` objects representing @eq-Pi for a specific binning, and using a specific resolution parameter $\sigma_z$.

```{python}
import numpy as np
import firecrown
from firecrown.generators.inferred_galaxy_zdist import ZDistLSSTSRD, InferredGalaxyZDist
from firecrown.metadata.two_point import MeasuredType, GalaxyMeasuredType

# These are the values at which we will evaluate the distribution.
z = np.linspace(0, 0.5, 1000)

# We use the same zdist_y1 and zdist_y10 that were created above.
# We create two GalaxyInferredZDist objects, one for Y1 and one for Y10.
Pz_y1 = zdist_y1.binned_distribution(
    zpl=0.2,
    zpu=0.3,
    sigma_z=0.01,
    z=z,
    name="bin1_y1",
    measured_type=GalaxyMeasuredType.COUNTS,
)
Pz_y10 = zdist_y10.binned_distribution(
    zpl=0.2,
    zpu=0.3,
    sigma_z=0.01,
    z=z,
    name="bin1_y10",
    measured_type=GalaxyMeasuredType.COUNTS,
)
assert isinstance(Pz_y1, InferredGalaxyZDist)
```

The plot of the $\textrm{d}N/\textrm{d}z$ distributions in these `GalaxyInferredZDist` objects is shown in @fig-inferred-dist.

```{python}
# | label: fig-inferred-dist
# | fig-cap: $\textrm{d}N/\textrm{d}z$ for both Year 1 and Year 10, using the formulation from the SRD, with the binning and resolution specified above.
# | fig-cap-location: margin
# | code-fold: true
# We have already imported plotnine, so we don't need to do that again.
# This time we generate the dataframe using a different technique.
d_y1 = pd.DataFrame({"z": Pz_y1.z, "dndz": Pz_y1.dndz, "year": "Y1"})
d_y10 = pd.DataFrame({"z": Pz_y10.z, "dndz": Pz_y10.dndz, "year": "Y10"})
data = pd.concat([d_y1, d_y10])

(
    ggplot(data, aes("z", "dndz", color="year"))
    + geom_point()
    + labs(y="dN/dz")
    + doc_theme()
)
```

