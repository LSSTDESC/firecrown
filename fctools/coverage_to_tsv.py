#!/usr/bin/env python3
"""
Convert pytest-cov JSON coverage data to TSV format.

This script reads a coverage.json file generated by pytest-cov and extracts
key information into a tab-separated values (TSV) file for easy analysis.
"""

import argparse
import json
import re
import sys
from pathlib import Path
from typing import Dict, Any, List, NamedTuple, Optional


class CoverageRecord(NamedTuple):
    """Structure for holding coverage data for a single function."""

    file_path: str
    function_name: str
    covered_lines: int
    total_statements: int
    percent_covered: float
    missing_lines: int
    excluded_lines: int
    num_branches: int
    covered_branches: int
    missing_branches: int
    num_partial_branches: int
    percent_covered_display: str
    file_total_statements: int
    file_covered_lines: int
    file_percent_covered: float
    test_duration: Optional[float] = None


def parse_timing_data(timing_file: Optional[Path]) -> Dict[str, float]:
    """
    Parse timing data from pytest --durations output or JSON file.

    Args:
        timing_file: Path to timing data file (JSON or text output)

    Returns:
        Dictionary mapping test names to duration in seconds
    """
    if timing_file is None or not timing_file.exists():
        return {}

    timing_data = {}

    try:
        # Try to parse as JSON first (from pytest-json-report)
        with open(timing_file, "r", encoding="utf-8") as f:
            data = json.load(f)

        # Handle pytest-json-report format
        if "tests" in data:
            for test in data["tests"]:
                test_name = test.get("nodeid", "")
                duration = test.get("duration", 0.0)
                timing_data[test_name] = duration

    except json.JSONDecodeError:
        # Try to parse as text output from pytest --durations
        try:
            with open(timing_file, "r", encoding="utf-8") as f:
                content = f.read()

            # Look for timing lines like "0.12s call tests/test_module.py::test_function"
            duration_pattern = r"(\d+\.?\d*s)\s+(call|setup|teardown)?\s*(.+)"
            for line in content.split("\n"):
                match = re.search(duration_pattern, line.strip())
                if match:
                    duration_str = match.group(1).rstrip("s")
                    test_name = match.group(3)
                    try:
                        duration = float(duration_str)
                        timing_data[test_name] = (
                            timing_data.get(test_name, 0.0) + duration
                        )
                    except ValueError:
                        continue

        except (OSError, KeyError):
            print(f"Warning: Could not parse timing data from {timing_file}")
            return {}

    return timing_data


def match_test_to_function(test_name: str, function_name: str, file_path: str) -> float:
    """
    Try to match a test name to a function for timing correlation.

    Args:
        test_name: Full test identifier (e.g., "tests/test_module.py::TestClass::test_method")
        function_name: Function name from coverage data
        file_path: File path from coverage data

    Returns:
        Relevance score (0.0 to 1.0) for the match
    """
    # Extract the base test file and method name
    if "::" in test_name:
        parts = test_name.split("::")
        test_file = parts[0]
        test_method = parts[-1]
    else:
        test_file = test_name
        test_method = ""

    score = 0.0

    # Check if test file corresponds to the source file
    if (
        file_path in test_file
        or test_file.replace("tests/", "").replace("test_", "") in file_path
    ):
        score += 0.3

    # Check if function name appears in test method name
    if function_name.lower() in test_method.lower():
        score += 0.5

    # Check if test method name appears in function name
    if test_method.replace("test_", "").lower() in function_name.lower():
        score += 0.4

    return min(score, 1.0)


def extract_coverage_data(
    coverage_data: Dict[str, Any], timing_data: Optional[Dict[str, float]] = None
) -> List[CoverageRecord]:
    """
    Extract coverage information from the JSON data, optionally including timing.

    Args:
        coverage_data: The loaded JSON coverage data
        timing_data: Optional dictionary of test timing data

    Returns:
        List of CoverageRecord objects containing detailed coverage information
    """
    # pylint: disable=too-many-locals
    results = []
    timing_data = timing_data or {}

    # Iterate through files in coverage data
    for file_path, file_data in coverage_data.get("files", {}).items():
        if "functions" not in file_data:
            continue

        # Get file-level summary data
        file_summary = file_data.get("summary", {})
        file_total_statements = file_summary.get("num_statements", 0)
        file_covered_lines = file_summary.get("covered_lines", 0)
        file_percent_covered = file_summary.get("percent_covered", 0.0)

        # Extract function-level coverage
        for function_name, func_data in file_data["functions"].items():
            summary = func_data.get("summary", {})

            # Try to find matching timing data
            best_duration = None
            best_score = 0.0

            if timing_data:
                for test_name, duration in timing_data.items():
                    score = match_test_to_function(test_name, function_name, file_path)
                    if (
                        score > best_score and score > 0.3
                    ):  # Minimum threshold for matching
                        best_score = score
                        best_duration = duration

            record = CoverageRecord(
                file_path=file_path,
                function_name=function_name,
                covered_lines=summary.get("covered_lines", 0),
                total_statements=summary.get("num_statements", 0),
                percent_covered=summary.get("percent_covered", 0.0),
                missing_lines=summary.get("missing_lines", 0),
                excluded_lines=summary.get("excluded_lines", 0),
                num_branches=summary.get("num_branches", 0),
                covered_branches=summary.get("covered_branches", 0),
                missing_branches=summary.get("missing_branches", 0),
                num_partial_branches=summary.get("num_partial_branches", 0),
                percent_covered_display=summary.get("percent_covered_display", "0"),
                file_total_statements=file_total_statements,
                file_covered_lines=file_covered_lines,
                file_percent_covered=file_percent_covered,
                test_duration=best_duration,
            )

            results.append(record)

    return results


def write_tsv_file(data: List[CoverageRecord], output_file: Path) -> None:
    """
    Write the extracted data to a TSV file.

    Args:
        data: List of CoverageRecord objects with coverage data
        output_file: Path to output TSV file
    """
    with open(output_file, "w", encoding="utf-8") as f:
        # Write header
        headers = [
            "file_path",
            "function_name",
            "covered_lines",
            "total_statements",
            "percent_covered",
            "missing_lines",
            "excluded_lines",
            "num_branches",
            "covered_branches",
            "missing_branches",
            "num_partial_branches",
            "percent_covered_display",
            "file_total_statements",
            "file_covered_lines",
            "file_percent_covered",
            "test_duration_seconds",
        ]
        f.write("\t".join(headers) + "\n")

        # Write data rows
        for record in data:
            duration_str = (
                str(record.test_duration) if record.test_duration is not None else ""
            )
            row = [
                record.file_path,
                record.function_name,
                str(record.covered_lines),
                str(record.total_statements),
                str(record.percent_covered),
                str(record.missing_lines),
                str(record.excluded_lines),
                str(record.num_branches),
                str(record.covered_branches),
                str(record.missing_branches),
                str(record.num_partial_branches),
                record.percent_covered_display,
                str(record.file_total_statements),
                str(record.file_covered_lines),
                str(record.file_percent_covered),
                duration_str,
            ]
            f.write("\t".join(row) + "\n")


def main():
    """Main function to convert coverage.json to TSV."""
    parser = argparse.ArgumentParser(
        description="Convert pytest-cov JSON coverage data to TSV format.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s coverage.json
  %(prog)s coverage.json output.tsv
  %(prog)s coverage.json output.tsv --timing timing.txt
  %(prog)s /path/to/coverage.json /path/to/output.tsv --timing timing.json
        """,
    )

    parser.add_argument(
        "input_file",
        type=Path,
        help="Path to the input JSON coverage file (e.g., coverage.json)",
    )

    parser.add_argument(
        "output_file",
        type=Path,
        nargs="?",
        default=Path("coverage_data.tsv"),
        help="Path to the output TSV file (default: coverage_data.tsv)",
    )

    parser.add_argument(
        "--timing",
        type=Path,
        help="Optional path to timing data file (JSON from pytest-json-report "
        "or text from pytest --durations)",
    )

    args = parser.parse_args()

    # Check if input file exists
    if not args.input_file.exists():
        print(f"Error: Input file '{args.input_file}' does not exist.")
        sys.exit(1)

    try:
        # Load JSON data
        print(f"Reading coverage data from {args.input_file}...")
        with open(args.input_file, "r", encoding="utf-8") as f:
            coverage_data = json.load(f)

        # Load timing data if provided
        timing_data = None
        if args.timing:
            print(f"Reading timing data from {args.timing}...")
            timing_data = parse_timing_data(args.timing)
            print(f"Loaded timing data for {len(timing_data)} tests")

        # Extract coverage data
        print("Extracting function-level coverage data...")
        extracted_data = extract_coverage_data(coverage_data, timing_data)

        # Write TSV file
        print(f"Writing {len(extracted_data)} records to {args.output_file}...")
        write_tsv_file(extracted_data, args.output_file)

        print("Successfully converted coverage data to TSV format!")
        print(f"Output file: {args.output_file}")
        print(f"Records written: {len(extracted_data)}")

        if timing_data:
            records_with_timing = sum(
                1 for record in extracted_data if record.test_duration is not None
            )
            print(f"Records with timing data: {records_with_timing}")

    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON in {args.input_file}: {e}")
        sys.exit(1)
    except OSError as e:
        print(f"Error: File operation failed: {e}")
        sys.exit(1)
    except KeyError as e:
        print(f"Error: Missing expected key in JSON data: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
